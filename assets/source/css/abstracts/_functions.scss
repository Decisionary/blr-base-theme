////
/// Functions.
///
/// @group Abstracts
///
/// scss-lint:disable ZeroUnit ColorVariable
////


/// Takes a valid breakpoint name and returns its width.
/// Returns null if the breakpoint is not defined.
///
/// @param {String} $breakpoint
///
/// @return {Number}
@function get-breakpoint( $breakpoint, $min-max: 'min' ) {

	@if not map-has-key( $breakpoints, $breakpoint ) {
		@warn "`#{$breakpoint}` is not a valid breakpoint name.";
		@return null;
	}

	$width: map-get( $breakpoints, $breakpoint );

	@if 'max' == $min-max {
		$width: $width - 0.000001rem;
	}

	@return $width;
}


/// Takes a color, determines whether it's dark or light, and returns a color
/// that contrasts it. For example, if the color is dark, a light color is
/// returned, and vice-versa. Used for things like alert boxes and buttons to
/// ensure that the text color is readable against the background color.
///
/// @param {Color} $base  The base color to contrast against.
/// @param {Color} $dark  [$color-dark]  The dark color to use.
/// @param {Color} $light [$color-light] The light color to use.
///
/// @return {Color}
@function ensure-contrast( $base, $dark: $color-dark, $light: $color-light ) {
	@return if( lightness( $base ) > 40, $dark, $light );
}


/// Slightly lighten a color.
///
/// @access public
///
/// @param {Color}  $color      - The color to tint.
/// @param {Number} $percentage - The percentage of `$color` in the returned color.
///
/// @return {Color}
@function tint( $color, $percentage ) {
	@return mix( #fff, $color, $percentage );
}

/// Slightly darken a color.
///
/// @param {Color} $color       - The color to shade.
/// @param {Number} $percentage - The percentage of `$color` in the returned color.
///
/// @return {Color}
@function shade( $color, $percentage ) {
	@return mix( #000, $color, $percentage );
}


/// Fetch a nested map value.
///
/// @param {Map}     $map  - The map.
/// @param {Arglist} $keys - A series of nested keys pointing to the value.
///
/// @return {*}
@function map-deep-get( $map, $keys... ) {

	@each $key in $keys {
		$map: map-get( $map, $key );
	}

	@return $map;
}


/// Update a nested map value.
///
/// @param {Map}     $map   - The map.
/// @param {Arglist} $keys  - A series of nested keys pointing to the value.
/// @param {*}       $value - The new value.
///
/// @return {Map} - Updated map
@function map-deep-set($map, $keys.../*, $value */) {

	$map-list: ( $map, );
	$result:   null;

	@if length( $keys ) == 2 {
		@return map-merge( $map, ( nth( $keys, 1 ): nth( $keys, -1 ) ) );
	}

	@for $i from 1 through length( $keys ) - 2 {
		$map-list: append( $map-list, map-get( nth( $map-list, -1 ), nth( $keys, $i ) ) );
	}

	@for $i from length( $map-list ) through 1 {
		$result: map-merge( nth( $map-list, $i ), ( nth( $keys, $i ): if( $i == length( $map-list ), nth( $keys, -1 ), $result ) ) );
	}

	@return $result;
}


/// Check if all the specified keys exist within a map.
///
/// @param {Map}     $map  - The map.
/// @param {Arglist} $keys - The keys to check for.
///
/// @return {Bool}
@function map-has-keys( $map, $keys... ) {

	@each $key in $keys {
		@if not map-has-key( $map, $key ) {
			@return false;
		}
	}

	@return true;
}


/// Check if all the specified keys exist within a map or any nested maps.
///
/// @param {Map}     $map  - The map.
/// @param {Arglist} $keys - The keys to check for.
///
/// @return {Bool}
@function map-has-nested-keys( $map, $keys... ) {

	@each $key in $keys {
		@if not map-has-key( $map, $key ) {
			@return false;
		}

		$map: map-get( $map, $key );
	}

	@return true;
}


/// Equivalent of the `zip` function for maps.
///
/// @param {List} $keys   - A list to use for the map keys.
/// @param {List} $values - A list to use for the map values.
///
/// @return {Map} The new map.
@function map-zip( $keys, $values ) {

	$num-keys:   length( $keys );
	$num-values: length( $values );

	$min: min( $num-keys, $num-values );
	$map: ();

	@if $num-keys != $num-values {
		@warn "#{$num-keys} key(s) and #{$num-values} value(s) were passed to \
			`map-zip`. The resulting map will only have #{$min} pairs.";
	}

	@if $min == 0 {
		@return $map;
	}

	@for $i from 1 through $min {
		$map: map-merge( $map, ( nth( $keys, $i ): nth( $values, $i ) ) );
	}

	@return $map;
}


/// Merges two maps together. Similar to jQuery's `extend` method.
///
/// @param {Map}     $map     - The base map.
/// @param {ArgList} $maps    - A list of map(s) to merge into the base map.
/// @param {Bool}    $shallow - True for shallow merge, false for deep merge.
///                             Disabled by default.
///
/// @return {Map}
@function map-extend( $map, $maps.../*, $shallow */ ) {

	$shallow: nth( $maps, -1 ) == false;
	$max:     if( $shallow, length( $maps ) - 1, length( $maps ) );

	// Loop through all the maps.
	@for $i from 1 through $max {

		$current: nth( $maps, $i );

		// See if we're doing a deep or shallow merge.
		@if $shallow {

			// Shallow - merge the current map into the base map.
			$map: map-merge( $map, $current );
		} @else {

			// Deep - loop through each tuple in the current map.
			@each $key, $value in $current {

				// If the current value is a map, AND the current key exists in
				// the base map, AND that value is *also* a map, then we merge
				// the two nested maps recursively.
				@if type-of( $value ) == 'map' and type-of( map-get( $map, $key ) ) == 'map' {
					$value: map-extend(map-get($map, $key), $value, true);
				}

				// Otherwise just merge current tuple into the base map.
				$map: map-merge( $map, ( $key: $value ) );
			}
		}
	}

	@return $map;
}


/// Removes the unit (e.g. px, em, rem) from a value, returning the number only.
/// Copied from Foundation.
///
/// @param {Number} $num - Number to strip unit from.
///
/// @return {Number} The same number, sans unit.
@function strip-unit( $num ) {
	@return $num / ( $num * 0 + 1 );
}

/// Converts pixel value into matching rem value.
/// Adapted from Foundation's `rem-calc` function.
///
/// @param {Number} $value - Value to convert.
/// @param {Number} $base [null] - The base value to use when calculating the `rem`. If this parameter is `null`, the function will reference the `$base-font-size` variable as the base.
///
/// @return {Number} The converted value.
@function rem-calc( $value, $base: null ) {

	// Check if the value is a number
	@if type-of( $value ) != 'number' {
		@warn inspect( $value ) + ' was passed to rem-calc(), which is not a number.';
		@return $value;
	}

	// If no base is defined, defer to the default font size
	@if $base == null {
		$base: 16px;
	}

	// If the base font size is a %, then multiply it by 16px
	// This is because 100% font size = 16px in most all browsers
	@if unit( $base ) == '%' {
		$base: ( $base / 100% ) * 16px;
	}

	// Calculate rem value.
	$value: strip-unit( $value ) / strip-unit( $base ) * 1rem;

	// Turn 0rem into 0
	@if $value == 0rem {
		$value: 0;
	}

	@return $value;
}
